{-# LANGUAGE DeriveFunctor         #-}
{-# LANGUAGE FlexibleInstances     #-}
{-# LANGUAGE GADTs                 #-}
{-# LANGUAGE LambdaCase            #-}
{-# LANGUAGE OverloadedStrings     #-}
{-# LANGUAGE ScopedTypeVariables   #-}

{-# OPTIONS_GHC -Wall -Werror #-}

module PaasSec.AgendaS1.Steps where

import Control.Monad.Free
import PaasSec.AgendaS1.Domain


-- | UserLogin is implicit and will be added by the dumper.
data Step a where
    Login          :: UserPass -> a -> Step a
    Logout         :: a -> Step a
    -- FIXME: user registration?  (either by BoardAssistence or register-by-email)

    ListUserAccs   :: ([UserLogin] -> a) -> Step a
    GetUserAcc     :: UserLogin -> (UserAcc -> a) -> Step a
    GetBadge       :: UserLogin -> (Maybe Badge -> a)  -> Step a
    AddUserAcc     :: UserAcc -> a -> Step a
    EditUserAcc    :: UserAcc -> UserAcc -> a -> Step a
    DelUserAcc     :: UserLogin -> a -> Step a

    ListProposals  :: ([ID Proposal] -> a) -> Step a
    GetProposal    :: ID Proposal -> (Proposal -> a) -> Step a
    AddProposal    :: ProtoProposal -> a -> Step a
    EditProposal   :: Proposal -> ProtoProposal -> a -> Step a
    DelProposal    :: Proposal -> a -> Step a

    MakeComment    :: ID Proposal -> ProtoComment -> a -> Step a
    GetComment     :: ID Comment -> (Comment -> a) -> Step a
    CastVote       :: ID Proposal -> Vote -> a -> Step a

    -- 'AnalyticsQuery': a query is a partial user account, a response is the number of users
    -- matching this query.  More interesting query types will likely be added in the future, like
    -- "how many users in age group 20-30 wrote any comments in the last month".  These query types
    -- will have to be reflected in the 'PartialUserAcc' type, and we need to model how they
    -- intersect in order to calculate our approximation of the @k@ value in @k-anonymity@.
    --
    -- The adversary model here says that analysts only submit lists of queries in batch and then
    -- forget about all the results before doing the next step.  a different adversary would be able
    -- to keep track of all steps over the course of a longer sequence of steps.  it is easy to
    -- implement the former in terms of the latter, but the other direction is less trival to show.
    -- we should clarify whether the two adversaries are equivalent, but for now we settle with the
    -- one that is potentially weaker.
    AnalyticsQuery :: [PartialUserAcc] -> ([NumUsers] -> a) -> Step a
  deriving Functor

type Behavior = Free Step


-- the following should be generated by TH.

login :: UserPass -> Behavior ()
login ps = liftF $ Login ps ()

logout :: Behavior ()
logout = liftF $ Logout ()


listUserAccs :: Behavior [UserLogin]
listUserAccs = liftF $ ListUserAccs id

getUserAcc :: UserLogin -> Behavior UserAcc
getUserAcc u = liftF $ GetUserAcc u id

getBadge :: UserLogin -> Behavior (Maybe Badge)
getBadge u = liftF $ GetBadge u id

addUserAcc :: UserLogin -> Behavior UserAcc
addUserAcc u = liftF $ GetUserAcc u id

editUserAcc :: UserAcc -> UserAcc -> Behavior ()
editUserAcc old new = liftF $ EditUserAcc old new ()

delUserAcc :: UserLogin -> Behavior ()
delUserAcc u = liftF $ DelUserAcc u ()


listProposals :: Behavior [ID Proposal]
listProposals = liftF $ ListProposals id

getProposal :: ID Proposal -> Behavior Proposal
getProposal i = liftF $ GetProposal i id

addProposal :: ProtoProposal -> Behavior ()
addProposal p = liftF $ AddProposal p ()

editProposal :: Proposal -> ProtoProposal -> Behavior ()
editProposal old new = liftF $ EditProposal old new ()

delProposal :: Proposal -> Behavior ()
delProposal p = liftF $ DelProposal p ()


makeComment :: ID Proposal -> ProtoComment -> Behavior ()
makeComment p c = liftF $ MakeComment p c ()

getComment :: ID Comment -> Behavior Comment
getComment c = liftF $ GetComment c id

castVote :: ID Proposal -> Vote -> Behavior ()
castVote p v = liftF $ CastVote p v ()


analyticsQuery :: [PartialUserAcc] -> Behavior [NumUsers]
analyticsQuery puas = liftF $ AnalyticsQuery puas id
